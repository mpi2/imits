#!/usr/bin/env ruby

if ! ARGV[0] or ! File.file?(ARGV[0])
  STDERR.puts 'Pass YAML file generated by targ_rep version of this script'
  exit 356
end

old_to_new_mgi_id_mapping = YAML.load_file(ARGV[0])

genes_with_old_mgi_ids = Gene.where(:mgi_accession_id => old_to_new_mgi_id_mapping.keys).all

ApplicationModel.audited_transaction do
  puts "NOTICE: #{genes_with_old_mgi_ids.count} genes with old MGI ids"
  genes_with_old_mgi_ids.each do |gene|
    new_mgi_id = old_to_new_mgi_id_mapping[gene.mgi_accession_id]
    new_gene = Gene.find_by_mgi_accession_id(new_mgi_id)
    if new_gene
      puts "WARNING: Gene #{gene.marker_symbol}(#{gene.mgi_accession_id}) needs to be re-MGI-id`ed, but another gene #{new_gene.marker_symbol}(#{new_gene.mgi_accession_id}) exists with the new MGI id already."
      if new_gene.mi_plans.count != 0 or new_gene.es_cells.count != 0
        puts "CRITICAL: New gene (#{new_gene.marker_symbol}) has #{new_gene.mi_plans.count} MiPlans and #{new_gene.es_cells.count} EsCells - cannot do simple rename"
        next
      end

      puts "NOTICE: Deleting new (empty) gene #{new_gene.marker_symbol} and changing attributes on old gene #{gene.marker_symbol} to match it"
      new_gene.destroy
      remote_gene_data = Gene.get_gene_data_from_remotes([new_mgi_id])
      updated_attributes = remote_gene_data[new_mgi_id]
      puts "NOTICE: Replacing old gene data:\n#{gene.attributes.to_yaml}\nwith new gene data:\n#{updated_attributes.to_yaml}"
      gene.update_attributes!(updated_attributes)
    else
      puts "NOTICE: Updating MGI id of #{gene.marker_symbol} from #{gene.mgi_accession_id} to #{new_mgi_id}"
      gene.update_attributes!(:mgi_accession_id => new_mgi_id)
    end
  end
  raise 'ROLLBACK'
end
